#!/bin/bash
#
# Awesome Devops (or yet another AirDrop)
#
# Copyright © 2021 Ouyang Xiongyi. All Rights Reserved.
#

CURDIR="`dirname $(readlink -f $0)`"
source $CURDIR/lib/common.sh

EXTERNAL_ROOT="${AD_EXTERNAL_DIR:-$CURDIR/../ad_external/awesome_devops}"
if [[ ! -d "$EXTERNAL_ROOT" ]]; then
    EXTERNAL_ROOT=""
fi

if [[ -z "$AD_DISABLE_EXTERNAL_AD" ]] && [[ -z "$AD_EXTERNAL_AD_PASSTHRU" ]] && [[ -n "$EXTERNAL_ROOT" ]] && [[ -x "$EXTERNAL_ROOT/ad" ]]; then
    _external_ad_real="$(readlink -f "$EXTERNAL_ROOT/ad")"
    _self_ad_real="$(readlink -f "$0")"
    if [[ "$_external_ad_real" != "$_self_ad_real" ]]; then
        AD_EXTERNAL_AD_PASSTHRU=1 AD_BASE_AD="$_self_ad_real" AD_EXTERNAL_DIR="$EXTERNAL_ROOT" exec "$EXTERNAL_ROOT/ad" "$@"
    fi
fi

merge_dir_entries()
{
    _relative_path="$1"
    {
        ls "$CURDIR/$_relative_path" 2> /dev/null
        if [[ -n "$EXTERNAL_ROOT" ]]; then
            ls "$EXTERNAL_ROOT/$_relative_path" 2> /dev/null
        fi
    } | awk 'NF' | sort -u
}

resolve_plugin_install()
{
    _plugin_name="$1"
    if [[ -f "$CURDIR/plugins/$_plugin_name/install" ]]; then
        echo "$CURDIR/plugins/$_plugin_name/install"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -f "$EXTERNAL_ROOT/plugins/$_plugin_name/install" ]]; then
        echo "$EXTERNAL_ROOT/plugins/$_plugin_name/install"
        return 0
    fi
    return 1
}

resolve_tool_file()
{
    _tool_name="$1"
    if [[ -f "$CURDIR/tools/$_tool_name" ]]; then
        echo "$CURDIR/tools/$_tool_name"
        return 0
    fi
    if [[ -f "$CURDIR/ext_tools/$_tool_name" ]]; then
        echo "$CURDIR/ext_tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -f "$EXTERNAL_ROOT/tools/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -f "$EXTERNAL_ROOT/ext_tools/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/ext_tools/$_tool_name"
        return 0
    fi
    return 1
}

resolve_named_tool_dir()
{
    _tool_name="$1"
    if [[ -f "$CURDIR/tools/$_tool_name/$_tool_name" ]]; then
        echo "$CURDIR/tools/$_tool_name"
        return 0
    fi
    if [[ -f "$CURDIR/ext_tools/$_tool_name/$_tool_name" ]]; then
        echo "$CURDIR/ext_tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -f "$EXTERNAL_ROOT/tools/$_tool_name/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -f "$EXTERNAL_ROOT/ext_tools/$_tool_name/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/ext_tools/$_tool_name"
        return 0
    fi
    return 1
}

resolve_tool_suite_dir()
{
    _tool_name="$1"
    if [[ -d "$CURDIR/tools/$_tool_name" ]]; then
        echo "$CURDIR/tools/$_tool_name"
        return 0
    fi
    if [[ -d "$CURDIR/ext_tools/$_tool_name" ]]; then
        echo "$CURDIR/ext_tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -d "$EXTERNAL_ROOT/tools/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/tools/$_tool_name"
        return 0
    fi
    if [[ -n "$EXTERNAL_ROOT" ]] && [[ -d "$EXTERNAL_ROOT/ext_tools/$_tool_name" ]]; then
        echo "$EXTERNAL_ROOT/ext_tools/$_tool_name"
        return 0
    fi
    return 1
}

# IPv4/IPv6 dual-stack support
# -g: allow brackets in URLs (for IPv6 addresses like [2001:db8::1])
# curl will automatically choose IPv4 or IPv6 based on DNS resolution
# To force IPv6: add -6 flag
# To force IPv4: add -4 flag
if [[ -n "$LR" ]]; then
    CURL="curl -g --limit-rate $LR"
else
    CURL="curl -g"
fi

# Optional: Uncomment to prefer IPv6 when both are available
# if [[ -n "$LR" ]]; then
#     CURL="curl -g -6 --limit-rate $LR"
# else
#     CURL="curl -g -6"
# fi

put()
{
    if [[ ! -f $1 ]]; then
        cecho -R "No such file"
        exit 1
    fi
    _name=`basename $1`
    _r_file=${2:-$_name}
    $CURL -T $1 $PUTURL/$_r_file > /dev/null
    if [[ $? -eq 0 ]]; then
        _res=(`md5sum $1`)
        cecho -Y "${_res[0]}"
        cecho -G "$GETURL/$_r_file"
        cecho -M "ad get $_r_file"
    fi
}

# [Comparison of Compression Algorithms]
# https://linuxreviews.org/Comparison_of_Compression_Algorithms
dput()
{
    # “:”会被tar认为是远程服务器
    if [[ $1 =~ .*:.* ]]; then
        cecho -R "not allow directory contain \":\""
        exit 1
    fi
    if [[ ! -d $1 ]]; then
        cecho -R "No such directory"
        exit 1
    fi
    _name=`basename $1`
    _parent=`dirname $1`
    if (type pigz >/dev/null 2>&1); then
        tar --no-xattrs -c -C $_parent --exclude='.git' -f - $_name | pigz > $_name.tgz
    else
        tar --no-xattrs -c -C $_parent --exclude='.git' -z -f $_name.tgz $_name
    fi
    $CURL -T $_name.tgz $PUTURL/$_name.tgz > /dev/null
    if [[ $? -eq 0 ]]; then
        _res=(`md5sum $_name.tgz`)
        cecho -Y "${_res[0]}"
        cecho -G "$GETURL/$_name.tgz"
        cecho -M "ad dget $_name"
    fi
    rm $_name.tgz
}

# [Comparison of Compression Algorithms]
# https://linuxreviews.org/Comparison_of_Compression_Algorithms
dgput()
{
    # “:”会被tar认为是远程服务器
    if [[ $1 =~ .*:.* ]]; then
        cecho -R "not allow directory contain \":\""
        exit 1
    fi
    if [[ ! -d $1 ]]; then
        cecho -R "No such directory"
        exit 1
    fi
    _name=`basename $1`
    _parent=`dirname $1`
    if (type pigz >/dev/null 2>&1); then
        tar --no-xattrs -c -C $_parent -f - $_name | pigz > $_name.tgz
    else
        tar --no-xattrs -c -C $_parent -z -f $_name.tgz $_name
    fi
    $CURL -T $_name.tgz $PUTURL/$_name.tgz > /dev/null
    if [[ $? -eq 0 ]]; then
        _res=(`md5sum $_name.tgz`)
        cecho -Y "${_res[0]}"
        cecho -G "$GETURL/$_name.tgz"
        cecho -M "ad dget $_name"
    fi
    rm $_name.tgz
}

tput()
{
    if [[ ! -f $1 ]]; then
        cecho -R "No such file"
        exit 1
    fi
    _name=`basename $1`
    _r_file=`date '+%Y-%m-%d_%H-%M-%S'`_${2:-$_name}
    $CURL -T $1 $PUTURL/$_r_file > /dev/null
    if [[ $? -eq 0 ]]; then
        _res=(`md5sum $1`)
        cecho -Y "${_res[0]}"
        cecho -G "$GETURL/$_r_file"
        cecho -M "ad get $_r_file"
    fi
}

get()
{
    _l_file=${2:-$1}
    temp_file="${_l_file}.download"
    if ! $CURL -fo "$temp_file" "$GETURL/$1"; then
        rm -f "$temp_file"
        cecho -R "Download failed"
        exit 1
    fi

    owner=""
    if [ -f "$_l_file" ]; then
        owner=$(stat -c "%U:%G" "$_l_file")
        permissions=$(stat -c "%a" "$_l_file")
    fi
    mv -f "$temp_file" "$_l_file"
    if [[ -n $owner ]]; then
        chown "$owner" "$_l_file"
        chmod "$permissions" "$_l_file"
    fi
    _res=(`md5sum "$_l_file"`)
    cecho -Y "${_res[0]}"
    cecho -G "$(readlink -f "$_l_file")"
}

dget()
{
    # “:”会被tar认为是远程服务器
    if [[ "$1" == *":"* ]]; then
        cecho -R 'filename must not contain ":"'
        exit 1
    fi

    _file_path="$1.tgz"
    _temp_file_path="${_file_path}.download"

    if $CURL -fo "$_temp_file_path" "$GETURL/$_file_path"; then
        mv -f "$_temp_file_path" "$_file_path"
        tar -x -o -f "$_file_path"
        cecho -Y "$(md5sum "$_file_path" | awk '{print $1}')"
        cecho -G "$(readlink -f "$1")"
        rm "$_file_path"
    else
        rm -f "$_temp_file_path"
        cecho -R "Download failed"
        exit 1
    fi
}

upgrade()
{
    bash <($CURL -s $GETURL/@aadi@)
}

ad_tree()
{
    tree -C $CURDIR -I '.git' -L 3
}

uninstall()
{
    rm -f ~/tmp/awesome_devops.tar ~/bin/ad
    rm -rf ~/.awesome_devops ~/.awesome_devops.bak
    sed -i '/ad-completion.bash/d' ~/.bashrc
    sed -i '/@ad_plugins@/d' ~/.bashrc
    echo "uninstall success"
}

publish_usage()
{
    cat <<__EOF__
Usage: ad publish [-f]

Publish and upload a new awesome_devops release.

Options:
  -f    Fast mode. Skip not_in_ad_tar packaging/upload.
  -h    Show this help message.
__EOF__
}

publish()
{
    _fast_mode=0
    while getopts ":fh" _opt; do
        case "$_opt" in
            f)
                _fast_mode=1
                ;;
            h)
                publish_usage
                exit 0
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                publish_usage >&2
                exit 1
                ;;
            \?)
                echo "Unknown option: -$OPTARG" >&2
                publish_usage >&2
                exit 1
                ;;
        esac
    done
    shift $((OPTIND - 1))

    if [[ $# -ne 0 ]]; then
        echo "Unexpected argument: $1" >&2
        publish_usage >&2
        exit 1
    fi

    VERSION_STR=${VERSION_STR:-}
    _fast_exclude_str=""

    source "$CURDIR/config"
    cd "$CURDIR"

    if [[ $_fast_mode -eq 1 ]]; then
        _fast_exclude_str="--exclude=not_in_ad_tar"
    fi

    # Only verify server reachability; latest_version may legitimately return 404 on first publish.
    curl --connect-timeout 1 -sS -o /dev/null "${GETURL}/@latest_version@" || {
        cecho -R "Unable to connect to ad server"
        exit 1
    }

    echo ". Recent changes:" >changelog.log
    git log -5 --pretty=format:"%ct %cI %s" >>changelog.log
    echo "" >>changelog.log
    git log -1 --pretty=format:"%ct" >latest_version

    rm -rf dist
    mkdir -p dist
    tar --no-xattrs -c -C .. \
        --exclude='awesome_devops/not_in_ad_tar/' \
        --exclude='awesome_devops/docs' \
        --exclude='awesome_devops/dist' \
        --exclude='.git' \
        --exclude='*.swp' \
        --exclude-from=<(git ls-files -oi --exclude-standard | sed 's|^|awesome_devops/|' | grep -vE 'awesome_devops/(changelog\.log|latest_version|config)$') \
        -f dist/awesome_devops.tar awesome_devops/
    rm -rf dist/awesome_devops
    tar x -C dist -f dist/awesome_devops.tar

    # 打包一些外部工具
    if [[ -d "$CURDIR/../ad_external" ]]; then
        rsync --filter=":- .gitignore" -avzP $_fast_exclude_str "$CURDIR/../ad_external/awesome_devops/" dist/awesome_devops
    fi

    if [[ $OSTYPE == 'darwin'* ]]; then
        SED=gsed
    else
        SED=sed
    fi

    # 替换访问地址
    $SED -i "s|@GETURL@|$GETURL|g" dist/awesome_devops/install.sh
    $SED -i "s|VERSION_STR|$VERSION_STR|g" dist/awesome_devops/install.sh

    # 临时替换common.sh，否则./ad无法执行
    _common_bak="$CURDIR/.common.sh.publish.$$"
    _restore_common() {
        if [[ -f "$_common_bak" ]]; then
            cp -f "$_common_bak" "$CURDIR/lib/common.sh"
            rm -f "$_common_bak"
        fi
    }
    trap _restore_common EXIT

    cp -f "$CURDIR/lib/common.sh" "$_common_bak"
    cp -f dist/awesome_devops/lib/common.sh "$CURDIR/lib/common.sh"
    source "$CURDIR/lib/common.sh"

    # 打包上传，不用tar z，因为有些环境tar不支持
    tar --no-xattrs -c -C dist --exclude='dist' --exclude='not_in_ad_tar' --exclude='.git' --exclude='*.swp' -f dist/awesome_devops.tar awesome_devops/
    "$CURDIR/ad" put dist/awesome_devops.tar "@awesome_devops${VERSION_STR}.tar@"
    "$CURDIR/ad" put dist/awesome_devops/install.sh "@aadi${VERSION_STR}@"
    "$CURDIR/ad" put latest_version "@latest_version${VERSION_STR}@"

    if [[ $_fast_mode -eq 1 ]]; then
        "$CURDIR/ad" cecho -C "skip not_in_ad_tar routine"
    else
        cd not_in_ad_tar
        for folder in */; do
            tgz_file="@${folder%/}.tgz@"
            tar --no-xattrs -czvf "$tgz_file" "$folder"
            "$CURDIR/ad" put "$tgz_file"
            rm "$tgz_file"
        done
        cd - >/dev/null
    fi

    cat changelog.log

    echo
    echo "Install link:"
    "$CURDIR/ad" cecho -Y "bash <(curl -s $GETURL/@aadi${VERSION_STR}@) && source ~/.bashrc"
}

new_version_detect()
{
    _old=`cat $CURDIR/latest_version`
    _new=`$CURL --connect-timeout 1 -sS $GETURL/'@latest_version@' 2>/dev/null`

    if [[ ! $? -eq 0 ]]; then
        cecho -Gy 'Unable to connect to ad server'
        return
    fi

    if [[ ! "$_new" =~ ^[0-9]+$ ]]; then
        return
    fi

    if [[ $_new -gt $_old ]]; then
        cecho -g 'A new version is available! Run "ad upgrade"'
    fi
}

usage(){

    cat <<__EOF__

⚙ Awesome Devops (or yet another AirDrop) ⚙

Usage:  ad [ COMMAND | TOOL | PLUGIN ] [ ARGUMENT ]

    BASIC COMMAND:
        help      # this message
        upgrade   # upgrade to latest version
        uninstall # leave no trace
        tree      # prints out ad directory in a tree-like display
        publish   # package and upload release artifacts
        [ put | tput | get ] <file>
        [ dput | dgput | dget ] <directory>

    TOOL:
__EOF__
    for i in `ls $CURDIR/tools/`; do
        usage_str=`grep "^${i}|" $CURDIR/tools/.usage | cut -d'|' -f2`
        num_char=${#i}
        if [[ -d $CURDIR/tools/$i ]]; then
            echo -n "        $i/"
            num_char=$((num_char + 1))
        else
            echo -n "        $i"
        fi
        if [[ -n "$usage_str" ]]; then
            printf "%$((20 - ${num_char}))s  ${usage_str}\n"
        else
            echo ""
        fi
    done

    cat <<__EOF__

    EXTERNAL TOOL:
__EOF__
    for i in `merge_dir_entries ext_tools`; do
        if [[ -e "$CURDIR/ext_tools/$i" ]]; then
            _ext_tool_entry="$CURDIR/ext_tools/$i"
        elif [[ -n "$EXTERNAL_ROOT" ]] && [[ -e "$EXTERNAL_ROOT/ext_tools/$i" ]]; then
            _ext_tool_entry="$EXTERNAL_ROOT/ext_tools/$i"
        else
            continue
        fi
        if [[ -d "$_ext_tool_entry" ]]; then
            echo "        $i/"
        else
            echo "        $i"
        fi
    done

    cat <<__EOF__

    PLUGIN install:
__EOF__
    for i in `merge_dir_entries plugins`; do
        echo "        deploy ${i##*/}"
    done

    cat <<__EOF__

Upload link:
$PUTURL

Install or Upgrade:
bash <(curl -s $GETURL/@aadi@) && source ~/.bashrc

Home page:
$SERVEFILE_URL
__EOF__

    new_version_detect

    [ "$_action" == "help" ] && exit 0 || exit 1
}

_action=$1; shift;

if [[ -z $_action ]]; then
    usage
    exit 1
fi

function tool_pre_run() {
    [[ -f "$1" ]] && bash "$1" || return 0
    if [[ $? -ne 0  ]]; then
        cecho -R "Abort: pre-run failed"
        return 1
    fi
}

case $_action in
    put | get | dput | dgput | dget | tput | upgrade | uninstall)
        $_action "$@"
        ;;
    publish)
        publish "$@"
        ;;
    help)
        usage
        ;;
    tree)
        ad_tree
        ;;
    deploy)
        _plugin=$1
        if [[ -z $_plugin ]]; then
            cecho -R "no plugin is specified! Select one:"
            for i in `merge_dir_entries plugins`; do
                echo "${i##*/}"
            done
            exit 1
        fi
        _plugin_install=`resolve_plugin_install "$_plugin"` || {
            cecho -R "unknown plugin: $_plugin"
            cecho -R "Select one:"
            for i in `merge_dir_entries plugins`; do
                echo "${i##*/}"
            done
            exit 1
        }
        shift
        "$_plugin_install" "$@"
        ;;
    ex)
        # install my experimental tool, will not be displayed in usage
        $CURDIR/experimental/$1/install
        ;;
    *)
        # 无目录工具，直接执行
        if _resolved_tool_file=`resolve_tool_file "$_action"`; then
            "$_resolved_tool_file" "$@"
        # 有目录工具，目录与工具名必须同名，直接执行
        elif _resolved_named_tool_dir=`resolve_named_tool_dir "$_action"`; then
            tool_pre_run "$_resolved_named_tool_dir/pre-run" || exit $?
            "$_resolved_named_tool_dir/$_action" "$@"
        # 有目录工具，目录与工具名不同名，一般是一个工具集，展示命令列表，或直接执行
        elif _path=`resolve_tool_suite_dir "$_action"`; then
            _tool=$1
            if [[ -z $_tool ]]; then
                if [[ -f "$_path/HELP" ]]; then
                    cecho -Y "Help:"
                    cat "$_path/HELP"
                fi
                cecho -Y "Tool List:"
                _list=`find "$_path/" -maxdepth 1 -perm -111 -type f`
                cecho -G "$_list"
            else
                shift
                tool_pre_run "$_path/pre-run" || exit $?
                "$_path/$_tool" "$@"
            fi
        else
            usage
            exit 1
        fi
        ;;
esac
