#!/bin/bash

#export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;export ALL_PROXY=socks5://127.0.0.1:1080
export LANG=en_US.UTF-8

# for mbp m1
eval "$(/opt/homebrew/bin/brew shellenv)"
export BASH_SILENCE_DEPRECATION_WARNING=1

export VISUAL=vim
export EDITOR="$VISUAL"
export PATH=/sbin:~/bin:$PATH
export PATH=/opt/homebrew/bin:$PATH
export PATH=$(brew --prefix)/opt/coreutils/libexec/gnubin:$PATH
export PATH=$(brew --prefix)/opt/binutils/bin:$PATH
export PATH=$(brew --prefix)/opt/findutils/libexec/gnubin:$PATH
export PATH=$(brew --prefix)/opt/grep/libexec/gnubin/:$PATH
export PATH=$(brew --prefix)/opt/ctags/bin:$PATH

TERM=xterm

__parse_git_branch() {
	#branch_symbol=""
	branch_symbol=""
	type git >/dev/null 2>&1
	if [ "$?" -ne 0 ]; then
		return
	fi

	#git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \[\1\]/'

	# Quit if this is not a Git repo.
	branch=$(git symbolic-ref HEAD 2> /dev/null)
	if [[ -z $branch ]] ; then
		# attempt to get short-sha-name
		branch=":$(git rev-parse --short HEAD 2> /dev/null)"
	fi
	if [ "$?" -ne 0 ]; then
		# this must not be a git repo
		return
	fi

	# Clean off unnecessary information.
	branch=${branch#refs\/heads\/}

	ad cecho -G "${branch_symbol} ${branch}"
}
export __parse_git_branch

__parse_git_ahead() {
	type git >/dev/null 2>&1
	if [ "$?" -ne 0 ]; then
		return
	fi

	#[[ -z $(git show HEAD 2> /dev/null) ]] && return

	# check if git
	[[ -z $(git rev-parse --git-dir 2> /dev/null) ]] && return

	symbolic_ref=$(git symbolic-ref -q HEAD)
	[[ -z "${symbolic_ref}" ]] && return

	tracking_branch=$(git for-each-ref --format='%(upstream:short)' ${symbolic_ref})

	# creates global variables $1 and $2 based on left vs. right tracking
	set -- $(git rev-list --left-right --count $tracking_branch...HEAD)

	behind=$1
	ahead=$2

	# print out the information
	if [[ $behind -gt 0 ]] ; then
		local ret="↓$behind"
	fi
	if [[ $ahead -gt 0 ]] ; then
		local ret="${ret}↑$ahead"
	fi
	ad cecho -B "$ret"
}
export __parse_git_ahead

__parse_git_stats(){
	type git >/dev/null 2>&1
	if [ "$?" -ne 0 ]; then
		return
	fi

	# check if git
	[[ -z $(git rev-parse --git-dir 2> /dev/null) ]] && return

	# return the number of modified but not staged items
	modified=$(git ls-files --modified `git rev-parse --show-cdup` | wc -l)
	ad cecho -M "+$modified" | tr -d '[:space:]'
}
export __parse_git_stats

__git_str()
{
	A=`__parse_git_branch`
	B=`__parse_git_ahead`
	C=`__parse_git_stats`
	echo "$B $C $A"
    echo""
}
export __git_str

PS1='╔║${debian_chroot:+($debian_chroot)}\[\033[1;33m\]\w\[\033[00m\] $(__git_str)\n╚═❯ '
#PS1='${debian_chroot:+($debian_chroot)}\[\033[1;35m\]\w\[\033[00m\]\n>> '

# for git information of tmux-powerline
#PS1="$PS1"'$([ -n "$TMUX" ] && tmux setenv TMUXPWD_$(tmux display -p "#D" | tr -d %) "$PWD")'

if [ -f $(brew --prefix)/etc/bash_completion ]; then
    . $(brew --prefix)/etc/bash_completion
fi

#All commands have been installed with the prefix 'g'.
#If you do not want the prefix, install using the "with-default-names" option.
#
#If you need to use these commands with their normal names, you
#can add a "gnubin" directory to your PATH from your bashrc like:
#
#    PATH="/usr/local/opt/make/libexec/gnubin:$PATH"
#
#Additionally, you can access their man pages with normal names if you add
#the "gnuman" directory to your MANPATH from your bashrc as well:
#
#    MANPATH="/usr/local/opt/make/libexec/gnuman:$MANPATH"

#curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash
source ~/.git-completion.bash

alias vi="vim"
alias d="sdcv"
alias ls='gls --color=auto'
alias ll='gls --color=auto -l'
alias la='gls --color=auto -A'
alias l='gls --color=auto -CF'
alias rr='xset r rate 250 50'
alias rm='grm'
alias cp='gcp'
alias rsync='rsync --filter=":- ~/.gitignore_global"'
alias chrome="open -a 'Google Chrome'"

#OS X Terminal equivalent of Ctrl+Left / Ctrl+Right
#https://apple.stackexchange.com/questions/1626/os-x-terminal-equivalent-of-ctrlleft-ctrlright
bind '"\e[5C": forward-word'
bind '"\e[5D": backward-word'
bind '"\e[1;5C": forward-word'
bind '"\e[1;5D": backward-word'

[ -e ~/.bashrc_ignored ] && . ~/.bashrc_ignored

_vps="-p 33333 root@172.188.29.150"
_vps2="-p 33333 root@120.24.253.41"
_nas="-p 2222 hh123okbb@192.168.31.2"

g()
{
    target="_$1"
    ssh ${!target}
}

source ~/.awesome_devops/ad-completion.bash

# XXX KNOWN ISSUES
# For bash users, autojump keeps track of directories by modifying $PROMPT_COMMAND. Do not overwrite $PROMPT_COMMAND
[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] && source ~/.autojump/etc/profile.d/autojump.sh
[ -f /opt/homebrew/etc/profile.d/autojump.sh ] && . /opt/homebrew/etc/profile.d/autojump.sh
alias s='j -s'
