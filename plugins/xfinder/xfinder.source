#!/bin/bash
# Copyright Â© 2019 Ouyang Xiongyi. All Rights Reserved.

#last_time=$(date +%s.%N)
#trace() {
#    now=$(date +%s.%N)
#    duration=$(echo "$now - $last_time" | bc)
#    printf "[%.9fs] %s\n" "$duration" "$BASH_COMMAND"
#    last_time=$now
#}
#trap trace DEBUG

SOURCE_PATH="~/.awesome_devops/plugins/xfinder/xfinder.source"
EDITOR_CMD="${EDITOR:-vi}"
XF_COLOR_ACTIVE=0
XF_C_RESET=""
XF_C_INDEX=""
XF_C_FIND_PATH=""
XF_C_PROMPT=""
XF_RG_COLOR_ARGS=()

### find

IGNORED_DIRS=(-name ".repo" -o -name ".git")

_run_editor() {
    local row="$1"
    local file="$2"

    if [ -n "$row" ]; then
        eval "$EDITOR_CMD +$row \"\$file\""
    else
        eval "$EDITOR_CMD \"\$file\""
    fi
}

function _xfind()
{
    local query="$*"
    find . \( "${IGNORED_DIRS[@]}" \) -prune -o -name "*$query*" -print
}

function _xfindi()
{
    local query="$*"
    find . \( "${IGNORED_DIRS[@]}" \) -prune -o -iname "*$query*" -print
}

_xf_color_enabled() {
    local color_setting="${XFINDER_COLOR:-1}"

    case "${color_setting}" in
        0|false|FALSE|False|no|NO|off|OFF)
            return 1
            ;;
    esac

    # Explicit setting forces color behavior regardless of TTY.
    if [ -n "${XFINDER_COLOR:-}" ]; then
        return 0
    fi

    # Default-on mode still avoids color in clearly non-interactive terminals.
    if [ ! -t 1 ] || [ "${TERM:-}" = "dumb" ]; then
        return 1
    fi

    return 0
}

_xf_detect_color_level() {
    local colors="0"
    if command -v tput >/dev/null 2>&1; then
        colors="$(tput colors 2>/dev/null || echo 0)"
    fi

    case "$colors" in
    ''|*[!0-9]*)
        colors=0
        ;;
    esac

    if [ "$colors" -ge 256 ]; then
        echo 256
    elif [ "$colors" -ge 8 ]; then
        echo 16
    else
        echo 0
    fi
}

_xf_init_palette() {
    XF_COLOR_ACTIVE=0
    XF_C_RESET=""
    XF_C_INDEX=""
    XF_C_FIND_PATH=""
    XF_C_PROMPT=""
    XF_RG_COLOR_ARGS=(--color=never)

    if ! _xf_color_enabled; then
        return
    fi

    XF_COLOR_ACTIVE=1
    XF_C_RESET=$'\033[0m'

    if [ "$(_xf_detect_color_level)" -ge 256 ]; then
        XF_C_INDEX=$'\033[38;5;81m'
        XF_C_FIND_PATH=$'\033[38;5;110m'
        XF_C_PROMPT=$'\033[38;5;214m'
        XF_RG_COLOR_ARGS=(
            --color=always
            --colors "path:fg:111"
            --colors "line:fg:111"
            --colors "column:fg:111"
            --colors "match:fg:203"
            --colors "match:style:bold"
        )
    else
        XF_C_INDEX=$'\033[1;36m'
        XF_C_FIND_PATH=$'\033[1;37m'
        XF_C_PROMPT=$'\033[1;33m'
        XF_RG_COLOR_ARGS=(
            --color=always
            --colors "path:fg:magenta"
            --colors "line:fg:magenta"
            --colors "column:fg:magenta"
            --colors "match:fg:red"
            --colors "match:style:bold"
        )
    fi
}

_xf_strip_ansi() {
    # Strip ANSI escape sequences for stable file:line parsing.
    sed -E $'s/\x1B\\[[0-9;?]*[ -/]*[@-~]//g'
}

_print_goto_prompt() {
    if [ "$XF_COLOR_ACTIVE" -eq 1 ]; then
        printf "%sgoto:%s " "$XF_C_PROMPT" "$XF_C_RESET"
    else
        printf "goto: "
    fi
}

_print_indexed_results() {
    local mode="$1"
    shift

    local i=1
    local line=""

    for line in "$@"; do
        if [ "$XF_COLOR_ACTIVE" -eq 1 ]; then
            if [ "$mode" = "find" ]; then
                printf "%s[%d]%s %s%s%s\n" "$XF_C_INDEX" "$i" "$XF_C_RESET" "$XF_C_FIND_PATH" "$line" "$XF_C_RESET"
            else
                printf "%s[%d]%s %s\n" "$XF_C_INDEX" "$i" "$XF_C_RESET" "$line"
            fi
        else
            printf "[%d] %s\n" "$i" "$line"
        fi
        i=$((i + 1))
    done
}

find_ed() {
    local cmd="$1"
    shift

    local -a lines=()
    local line=""
    while IFS= read -r line; do
        lines+=("$line")
    done < <("$cmd" "$@")

    if [ "${#lines[@]}" -eq 0 ]; then
        return
    fi

    _xf_init_palette

    clear
    _print_indexed_results find "${lines[@]}"

    while true; do
        local num=""
        _print_goto_prompt
        if ! read -r num; then
            return
        fi

        if [[ ! "$num" =~ ^[0-9]+$ ]]; then
            return
        fi

        if [ "$num" -lt 1 ] || [ "$num" -gt "${#lines[@]}" ]; then
            return
        fi

        _run_editor "" "${lines[$((num - 1))]}"

        clear
        _print_indexed_results find "${lines[@]}"
    done
}

alias xfind="find_ed _xfind"
alias xfindi="find_ed _xfindi"

### grep

RG_BASE_OPTS=(
    --vimgrep
    --hidden
    --no-ignore
    --glob "!.git/**"
    --glob "!.repo/**"
)

RG_TAGS_GLOBS=(
    "!tags-e"
    "!tags"
    "!cscope.out"
    "!ncscope.out"
    "!GPATH"
    "!GRTAGS"
    "!GTAGS"
)

RG_C_GLOBS=(
    "*.c"
    "*.cc"
    "*.cpp"
    "*.h"
)

RG_OTHER_SRC_GLOBS=(
    "*.g"
    "*.lua"
    "*.java"
    "*.xml"
    "*.S"
    "*.patch"
    "*.diff"
    "*.log"
    "*.txt"
)

RG_PY_GLOBS=(
    "*.py"
)

RG_MAKE_GLOBS=(
    "Makefile"
    "makefile"
    "meson.build"
    "CMakeLists.txt"
    "*.mk"
)

_rg_require() {
    if ! command -v rg >/dev/null 2>&1; then
        echo "xfinder: rg is required for *grep commands." >&2
        return 127
    fi
}

_rg_search() {
    local ignore_case="$1"
    local profile="$2"
    local output_mode="plain"
    if [ "${3:-}" = "interactive" ] || [ "${3:-}" = "plain" ]; then
        output_mode="$3"
        shift 3
    else
        shift 2
    fi

    _rg_require || return $?

    local -a cmd=(rg "${RG_BASE_OPTS[@]}")
    local glob=""

    if [ "$ignore_case" = "1" ]; then
        cmd+=(-i)
    fi

    case "$profile" in
    x)
        for glob in "${RG_TAGS_GLOBS[@]}"; do
            cmd+=(--glob "$glob")
        done
        ;;
    c)
        for glob in "${RG_C_GLOBS[@]}"; do
            cmd+=(-g "$glob")
        done
        ;;
    s)
        for glob in "${RG_C_GLOBS[@]}"; do
            cmd+=(--glob "!$glob")
        done
        for glob in "${RG_MAKE_GLOBS[@]}"; do
            cmd+=(--glob "!$glob")
        done
        for glob in "${RG_OTHER_SRC_GLOBS[@]}"; do
            cmd+=(--glob "!$glob")
        done
        for glob in "${RG_PY_GLOBS[@]}"; do
            cmd+=(--glob "!$glob")
        done
        for glob in "${RG_TAGS_GLOBS[@]}"; do
            cmd+=(--glob "$glob")
        done
        cmd+=(--glob "!*.rst" --glob "!*.md")
        ;;
    m)
        for glob in "${RG_MAKE_GLOBS[@]}"; do
            cmd+=(-g "$glob")
        done
        ;;
    o)
        for glob in "${RG_OTHER_SRC_GLOBS[@]}"; do
            cmd+=(-g "$glob")
        done
        ;;
    p)
        for glob in "${RG_PY_GLOBS[@]}"; do
            cmd+=(-g "$glob")
        done
        ;;
    *)
        echo "xfinder: unknown grep profile '$profile'" >&2
        return 2
        ;;
    esac

    if [ "$output_mode" = "interactive" ]; then
        _xf_init_palette
        cmd+=("${XF_RG_COLOR_ARGS[@]}")
    else
        cmd+=(--color=never)
    fi

    "${cmd[@]}" "$@" 2>/dev/null
}

grep_ed() {
    local cmd="$1"
    shift

    local profile=""
    local ignore_case="0"
    case "$cmd" in
    _xgrep) profile="x" ;;
    _xgrepi) profile="x"; ignore_case="1" ;;
    _cgrep) profile="c" ;;
    _cgrepi) profile="c"; ignore_case="1" ;;
    _sgrep) profile="s" ;;
    _sgrepi) profile="s"; ignore_case="1" ;;
    _mgrep) profile="m" ;;
    _mgrepi) profile="m"; ignore_case="1" ;;
    _ogrep) profile="o" ;;
    _ogrepi) profile="o"; ignore_case="1" ;;
    _pgrep) profile="p" ;;
    _pgrepi) profile="p"; ignore_case="1" ;;
    esac

    local -a lines=()
    local line=""
    if [ -n "$profile" ]; then
        while IFS= read -r line; do
            lines+=("$line")
        done < <(_rg_search "$ignore_case" "$profile" interactive "$@")
    else
        while IFS= read -r line; do
            lines+=("$line")
        done < <("$cmd" "$@")
    fi

    if [ "${#lines[@]}" -eq 0 ]; then
        return
    fi

    _xf_init_palette

    clear
    _print_indexed_results grep "${lines[@]}"

    while true; do
        local num=""
        _print_goto_prompt
        if ! read -r num; then
            return
        fi

        if [[ ! "$num" =~ ^[0-9]+$ ]]; then
            return
        fi

        if [ "$num" -lt 1 ] || [ "$num" -gt "${#lines[@]}" ]; then
            return
        fi

        local selected="${lines[$((num - 1))]}"
        selected="$(printf '%s\n' "$selected" | _xf_strip_ansi)"
        local file="${selected%%:*}"
        local rest="${selected#*:}"
        local row="${rest%%:*}"
        _run_editor "$row" "$file"

        clear
        _print_indexed_results grep "${lines[@]}"
    done
}

grep_fact() {
	while [ -n "$1" ]; do
		local _suffix=$1
		eval "alias $1grep=\"grep_ed _$1grep\""
		eval "alias $1grepi=\"grep_ed _$1grepi\""
		shift
	done
}

function _xgrep() {
    _rg_search 0 x plain "$@"
}

function _xgrepi() {
    _rg_search 1 x plain "$@"
}

function _cgrep()
{
    _rg_search 0 c plain "$@"
}

function _cgrepi()
{
    _rg_search 1 c plain "$@"
}

function _sgrep()
{
    _rg_search 0 s plain "$@"
}

function _sgrepi()
{
    _rg_search 1 s plain "$@"
}

function _mgrep()
{
    _rg_search 0 m plain "$@"
}

function _mgrepi()
{
    _rg_search 1 m plain "$@"
}

function _ogrep()
{
    _rg_search 0 o plain "$@"
}

function _ogrepi()
{
    _rg_search 1 o plain "$@"
}

function _pgrep()
{
    _rg_search 0 p plain "$@"
}

function _pgrepi()
{
    _rg_search 1 p plain "$@"
}

grep_fact c o m s x p
